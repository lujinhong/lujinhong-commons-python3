# -*- coding: utf-8 -*-

"""
     AUTHOR: lujinhong
 CREATED ON: 2019年09月26日 10:59
    PROJECT: lujinhong-commons-python3
DESCRIPTION: TODO
"""

import math
import time


class PacingSimulation:

    init_tau = 0.01
    epsilon = 0.001
    init_rl = 0.98

    B_list = [104.17 for x in range(144)]
    C_list = [0 for x in range(144)]
    G = 50

    #概率区间累积人群规模。select ceil(pro*100),count(1) from edt.edt_model_proi_day where ds=20191019 and campaign='33204' group by ceil(pro*100) order by ceil(pro*100) desc;
    cdf_list = [0.00004008,0.00009590,0.00016385,0.00023480,0.00032012,0.00040564,0.00049313,0.00058530,0.00068914,0.00079346,0.00090360,0.00102316,0.00115120,0.00129069,0.00143582,0.00159159,0.00175384,0.00193262,0.00212785,0.00234239,0.00256271,0.00280268,0.00306058,0.00335300,0.00369409,0.00406033,0.00447726,0.00491481,0.00539963,0.00592335,0.00653017,0.00718976,0.00792998,0.00886964,0.00981795,0.01091335,0.01226705,0.01406268,0.01608152,0.01840134,0.02143964,0.02477538,0.02822058,0.03209441,0.03629687,0.04117018,0.04701356,0.05448862,0.06641407,0.08013652,0.09555817,0.11341514,0.13331997,0.15511484,0.17907739,0.20432662,0.23040689,0.25729306,0.28472391,0.31212810,0.33934009,0.36601460,0.39188188,0.41686731,0.44079652,0.46375073,0.48565579,0.50677003,0.52697994,0.54628965,0.56491120,0.58293830,0.60040675,0.61739557,0.63391725,0.65007233,0.66588410,0.68125290,0.69641539,0.71129384,0.72587737,0.74023163,0.75440068,0.76841399,0.78229131,0.79601284,0.80965057,0.82326923,0.83690452,0.85069349,0.86453315,0.87862148,0.89288828,0.90748585,0.92252445,0.93799308,0.95378899,0.96992934,0.98600502,1.00000000]
    cdf_list.reverse()
    pdf_list = [0.00004008,0.00005582,0.00006795,0.00007095,0.00008532,0.00008552,0.00008748,0.00009217,0.00010385,0.00010432,0.00011013,0.00011956,0.00012804,0.00013949,0.00014513,0.00015577,0.00016225,0.00017878,0.00019523,0.00021454,0.00022032,0.00023997,0.00025790,0.00029242,0.00034109,0.00036624,0.00041693,0.00043755,0.00048482,0.00052372,0.00060682,0.00065959,0.00074022,0.00093966,0.00094831,0.00109540,0.00135370,0.00179563,0.00201884,0.00231982,0.00303830,0.00333574,0.00344520,0.00387383,0.00420246,0.00487330,0.00584339,0.00747505,0.01192545,0.01372246,0.01542165,0.01785697,0.01990483,0.02179487,0.02396255,0.02524923,0.02608027,0.02688617,0.02743085,0.02740419,0.02721199,0.02667452,0.02586727,0.02498543,0.02392921,0.02295421,0.02190506,0.02111424,0.02020991,0.01930971,0.01862155,0.01802711,0.01746844,0.01698882,0.01652168,0.01615508,0.01581177,0.01536880,0.01516248,0.01487845,0.01458353,0.01435426,0.01416905,0.01401331,0.01387733,0.01372153,0.01363772,0.01361867,0.01363528,0.01378897,0.01383966,0.01408833,0.01426680,0.01459757,0.01503860,0.01546863,0.01579591,0.01614034,0.01607568,0.01399498]
    pdf_list.reverse()
    #每个概率区间的转化率。报表：概率区间离线监控。 TODO:需要考虑0的情况。
    R_list = [0.0088409 ,0.0084240 ,0.0054860 ,0.0041736 ,0.0033250 ,0.0036848 ,0.0035854 ,0.0020860 ,0.0021868 ,0.0022197 ,0.0020480 ,0.0011229 ,0.0014030 ,0.0009130 ,0.0015500 ,0.0012320 ,0.0008284 ,0.0013104 ,0.0009007 ,0.0005437 ,0.0006662 ,0.0006260 ,0.0005491 ,0.0006109 ,0.0006027 ,0.0004682 ,0.0005014 ,0.0004781 ,0.0004382 ,0.0004507 ,0.0003190 ,0.0003995 ,0.0002698 ,0.0003365 ,0.0002010 ,0.0002363 ,0.0002125 ,0.0002930 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ,0.0000000 ]
    R_list.reverse()
    #每10分钟的请求量。某一天的数据，可以考虑多天平均。
    req_list = [20573,19727,18505,23776,22134,20826,18950,17566,15794,14562,13062,12313,11111,10566,9747,9154,8621,7916,7384,7249,6931,6475,6194,5827,5519,5340,5250,4983,4878,4785,4662,4968,4847,4849,5029,5427,5754,6977,7574,8695,9895,11315,12327,14530,15725,16317,17673,19382,19026,20927,21427,21619,22235,22879,23499,24664,24711,24791,24863,25378,25396,26245,26519,25716,27248,26779,28228,28885,27347,27878,28171,27975,26547,27217,27001,27374,26340,26686,26795,27942,27583,27155,27934,28076,27504,28011,27419,27375,27671,27712,28069,28082,28180,27596,28253,28768,27516,29575,28428,29126,29364,29235,28670,29889,27890,29257,27630,29144,26957,27472,26242,27379,25722,25968,24720,24929,24982,24401,24533,24876,24893,26083,26328,25901,26429,27789,28007,26910,26997,26861,27356,27920,28267,28379,28196,29042,28422,27620,27650,26451,25429,25104,23187,22582]
    #每10分钟的CPM。用活动实时数据里面的每10分钟消耗除以每10分钟曝光，再乘以1000。
    cpm_list = [32.00146852,36.31284916,37.67335955,37.46143676,37.64527539,39.5256917,40.98657962,42.01107797,43.31770223,43.31413948,45.29667149,43.50758853,44.84732824,45.42743539,45.33898305,44.76940382,44.19695193,45.23809524,44.81327801,44.7826087,47.05882353,46.81978799,46.67896679,44.87427466,46.0251046,46.44549763,46.66666667,45.22144522,45.6185567,43.50961538,44.87804878,43.93939394,43.19654428,44.28571429,41.898527,41.59159159,40.60150376,40.52156469,39.28571429,39.26571251,39.09044456,38.49667774,39.4686907,40.13605442,40.8045977,40.92805005,40.91726619,40.04106776,40.35692557,40.54301963,39.60060924,39.40809969,38.92427459,38.45101259,39.22366992,39.52825298,39.20090464,39.87987988,39.47523933,39.38099088,40.0806356,41.11822947,40.53899737,40.84426697,41.17308798,41.21226036,41.8424353,41.51311511,41.27989516,41.75300456,41.69590057,41.92872117,40.96709201,40.8393866,40.28007238,39.79215096,39.76734749,40.26288923,40.30685216,40.26682838,39.94285004,39.62703963,39.81085053,39.98217355,40.6995644,40.61046702,40.8445146,40.91893024,41.04951333,41.26497225,41.54618779,41.75654854,41.37720437,41.27942999,41.4732281,41.59271549,41.68847026,41.46889833,41.43412819,41.99933466,41.67719121,41.76205889,41.28440367,41.80373907,41.24931706,41.76313446,41.07785482,40.89944845,40.87486554,41.28069071,40.61731536,40.72139709,40.0034118,39.81825692,39.40455342,39.80352304,38.98849797,39.30870891,38.91342388,38.60815962,38.30627845,38.54223327,37.85565022,38.91762833,38.14109914,38.12549643,37.71752327,38.2109946,38.1508438,38.39256603,38.38141026,38.07725592,38.08415101,38.81556096,39.21752153,39.05255946,39.80820696,39.45627331,40.53227287,40.74562851,41.1551098,41.53354633,45.25089606,51.77514793]
    #从出价到曝光的比例。用流量资源的数据近似。流量资源实时监控里面的每10分钟曝光除以每10分钟出价。
    W_list = [0.106550218,0.131357049,0.129888268,0.10141844,0.097202797,0.08259773,0.085413929,0.088802083,0.100572738,0.080576441,0.078321678,0.078267254,0.073656846,0.072934974,0.066799205,0.065611814,0.073672055,0.071536524,0.068503937,0.064102564,0.062162162,0.066961652,0.076547231,0.068333333,0.067957746,0.063868613,0.059778598,0.060769231,0.065338645,0.070044053,0.070909091,0.06547619,0.073305085,0.066814159,0.074666667,0.07751004,0.080632411,0.078193146,0.085582822,0.094516971,0.095454545,0.102584493,0.096886447,0.109984871,0.097560976,0.090359897,0.087639061,0.0910299,0.089377682,0.12458287,0.100234192,0.098239437,0.101052632,0.101065089,0.092776524,0.089384289,0.122770199,0.091694352,0.083389831,0.081758958,0.078366914,0.0721875,0.074294671,0.073635427,0.093273543,0.065403304,0.0608,0.054180887,0.058563536,0.05770235,0.062564544,0.059538598,0.068306528,0.085761865,0.111516035,0.098189415,0.121501706,0.088652482,0.089031339,0.079343365,0.106578947,0.090973202,0.097777778,0.085771277,0.085530547,0.082851638,0.091597796,0.1,0.103154305,0.089721254,0.085055644,0.08110176,0.075446724,0.074766355,0.08276714,0.082843713,0.087985437,0.075668624,0.078482668,0.082628497,0.081697277,0.078287462,0.089420655,0.080362929,0.089273356,0.078605605,0.074927954,0.103742613,0.088450292,0.086657497,0.087431694,0.094197438,0.095277548,0.108173077,0.106643357,0.113537118,0.111702128,0.109259259,0.107933579,0.141218005,0.119136961,0.110280374,0.138733706,0.132352941,0.131008483,0.12354521,0.126833477,0.133211679,0.141643059,0.125475285,0.133512545,0.116406966,0.117068811,0.107480653,0.103690685,0.099913119,0.110035211,0.099630996,0.099462366,0.102941176,0.097131553,0.092393509,0.091501104,0.072746781]

    #我们的方法
    def greey_linear_search_pacing(self, pre_rl=init_rl, tau=init_tau, time_slot=0, flag=0):
        # localtime = time.localtime(time.time())
        # time_slot = int((localtime.tm_hour * 60 + localtime.tm_min)/10)

        rl = pre_rl
        #截止当前时刻的预算误差
        E_cb = 0
        for i in range(0,time_slot):
            E_cb += (self.C_list[i] - self.B_list[i])
        #剩余时间段的所有预算
        remain_B = 0
        for i in range(time_slot,144):
            remain_B += self.B_list[time_slot]
        #经调整后，本次时间段需要消耗的费用
        modify_B = self.B_list[time_slot] - E_cb * self.B_list[time_slot] / remain_B

        while abs(tau) > self.epsilon and 0 < rl < 1:
            rl = rl + tau
            if rl > 1: rl = 1
            if rl < 0: rl = 0

            cost_rl = self.cdf_list[math.ceil(rl * 100)] * self.req_list[time_slot] * 60 * 10 * self.W_list[time_slot] * self.cpm_list[time_slot] / 1000.0
            conv_rl = 0 #避免分母为0
            for i in range(math.ceil(rl * 100) , 100):
                conv_rl += self.pdf_list[i] * self.req_list[time_slot] * 60 * 10  * self.W_list[time_slot] * self.R_list[i]
            Prl = cost_rl / conv_rl
            if Prl <= self.G and cost_rl <= modify_B:
                flag = 1
                tau = -abs(tau)
            else:
                if flag == 1:
                    rl = rl - tau
                    tau = tau/2.0
        #debu log begin
        cost_rl = self.cdf_list[math.ceil(rl * 100)] * self.req_list[time_slot] * 60 * 10 * self.W_list[time_slot] * self.cpm_list[time_slot] / 1000.0
        conv_rl = 0 #避免分母为0
        for i in range(math.ceil(rl * 100) , 100):
            conv_rl += self.pdf_list[i] * self.req_list[time_slot] * 60 * 10  * self.W_list[time_slot] * self.R_list[i]
        print(rl, cost_rl, conv_rl, cost_rl/conv_rl, modify_B)
        #log end
        self.C_list[time_slot] = cost_rl
        return rl

    #参考文献的方法
    def greey_linear_search_pacing_paper(self, pre_rl=init_rl, tau=init_tau, time_slot=0, flag=0):
        # localtime = time.localtime(time.time())
        # time_slot = int((localtime.tm_hour * 60 + localtime.tm_min)/10)

        rl = pre_rl
        #截止当前时刻的预算误差
        E_cb = 0
        for i in range(0,time_slot):
            E_cb += (self.C_list[i] - self.B_list[i])
        #剩余时间段的所有预算
        remain_B = 0
        for i in range(time_slot,144):
            remain_B += self.B_list[time_slot]
        #经调整后，本次时间段需要消耗的费用
        modify_B = self.B_list[time_slot] - E_cb * self.B_list[time_slot] / remain_B

        while abs(tau) > self.epsilon and 0 < rl < 1:
            rl = rl + tau
            if rl > 1: rl = 1
            if rl < 0: rl = 0

            cost_rl = self.cdf_list[math.ceil(rl * 100)] * self.req_list[time_slot] * 60 * 10 * self.W_list[time_slot] * self.cpm_list[time_slot] / 1000.0
            conv_rl = 0 #避免分母为0
            for i in range(math.ceil(rl * 100) , 100):
                conv_rl += self.pdf_list[i] * self.req_list[time_slot] * 60 * 10  * self.W_list[time_slot] * self.R_list[i]
            Prl = cost_rl / conv_rl
            if cost_rl <= modify_B:
                flag = 1
                tau = -abs(tau)
            else:
                if flag == 1:
                    rl = rl - tau
                    tau = tau/2.0
        #debu log begin
        cost_rl = self.cdf_list[math.ceil(rl * 100)] * self.req_list[time_slot] * 60 * 10 * self.W_list[time_slot] * self.cpm_list[time_slot] / 1000.0
        conv_rl = 0 #避免分母为0
        for i in range(math.ceil(rl * 100) , 100):
            conv_rl += self.pdf_list[i] * self.req_list[time_slot] * 60 * 10  * self.W_list[time_slot] * self.R_list[i]
        print(rl, cost_rl, conv_rl, cost_rl/conv_rl, modify_B)
        #long end
        self.C_list[time_slot] = cost_rl
        return rl


if __name__ == '__main__':
    ps = PacingSimulation()
    for i in range(0,144):
        rl = ps.greey_linear_search_pacing(pre_rl= 0.98, time_slot=i)
        # rl = ps.greey_linear_search_pacing_paper(pre_rl= 0.98, time_slot=i)
        # print(rl)